;תוכנית שפותרת סודקו בגודל 4 על 4,הפתרון מבוסס על אלוגרתיום
;Backtracking
;הפתרון הוא כזה:
;ניצור סודוקו בקלט
;תוך ווידאוי שהקלט שומר על החוקים
;התכנית תנסה למלא לפי חוקי הסודקו,במידה והגענו למבוי סתום,נשאיר את המיקום הריק ריק נחזור למיקום הקודם,נעלה את המיקום הקודם ב 1 ונמשיך את המילוי
;במידה וצריך נחזור אותו עוד יותר מוקדם עד המקום הפנוי הראשון שמצאנו במערך המיקומים
;לתוכנית יש שתי אפשרויות עצירה:
;במידה ומונה אורך המטריצה המלא מתאפס
;או שהאיבר במיקום הפנוי הראשון שמצאנו אינו ניתן למילוי,על ידי כך שהוא מגיע ל 5 או שהמיקום נשאר ריק בפעם הראשונה,כי המילוי לא עומד בתנאים
;מונה המטריצה אינו יכול להתאפס כל עוד לא פתרנו את הסודקו,וכאשר יש שגיאות הוא חוזר לערכו ההתחלתי
;אין פה לולאה אינסופית,לפחות לא אין מוצא משום שבמקרה שאין אפשרות לפתרון האיבר במיקום הפנוי הראשון יגיע ל5,יסיים את התוכנית ונדפיס הודעת שגיאה
;במידה ולא ניתן בקטע הקליטה לקלוט איבר שעומד על התנאים יהיה אפשר ללחוץ אסקייפ ולסיים את התכנית,התכנית תודיעה על הודעת שגיאה כי במצב כזה
;מונה המטריצה אינו יכול להתאפס בזמן הקלט,ולא ניתן לפתור את הסודקו
FIRSTLOCATION EQU 0;מיקום ראשון במערך המיקומים
TRUE       EQU  1;נכון,1
FALSE      EQU  0;לא נכון,0
AboveSpace EQU  '!';מעל תו פנוי,לבדיקה אם עברנו בפעם הראשונה ויכולנו למאלות או לא
ESC1     EQU     27;הגדרת כפתור אסקייפ שנוכל לצאת מקטא המילוי
 N       EQU     4;רוחב ואורך המטריצה
 MAX     EQU    '5';משתנה  שמכיל את המקסימום  שאיבר יכול להגיע,במידה ויגיע אליו סימן שלא ניתן למלאות את התא לפי החוקים
;ניצור מקרויים לפני תחילת התכנית
;מקרו שממיר את אוגר האינדקס למיקום המטריצה
COR2OFF MACRO
        PUSH    AX;דוחף את AX למחסנית
        PUSH    BX;דוחף את BX למחסנית
        PUSHF
        MOV     BL , AH
        MOV     BH , N
        MUL     BH
        XOR     BH , BH ; BX = BL = AH;
        ADD     AX , BX;נוסיף את הערך האוגר המשני לאוגר הראשי כדיי לקבל את מיקום האינדקס בצורה רגילה
        MOV     SI , AX;נשים את הערך המומר באוגר האינדקס
        POPF;נשחזר את האוגרים ונסיים את המקרו
        POP     BX
        POP     AX
endm 

;מקרו לתחילת ריבוע קסם
Magic_Square_Location MACRO
;אתחול האוגרים
xor ax,ax
xor bx,bx;
mov al,N;יקבל את גודל רוחב המטריצה
MOV bL,miniN;מחלק בשורש של רוחבה מטריצה
div bl;
.IF(TEMPJ2==AX);האם שווה שורש?
ADD TEMPI3,AX;נעבור לתחילת הריבוע הבא
.ENDIF;
ENDM;סיום המקרו

;מקרו ליצירת רווח שורה
MOVDOWN MACRO
mov DL, 0DH
mov DL, 0AH
int 21H;הדפסת הרווח
ENDM;סיום המקרו

;מקרו קליטה
KELET MACRO
     MOV     AH , 7
     INT     21H;הדפסת הקלט
ENDM


;מקרו לבדיקת קלט שורה
CHK_KELET_SHURA MACRO
LOCAL NEXT1,PRE,NEXT0, SOF , L1 ;הגדרת תווים לוקלים
;שמירת האוגרים
       push si
       push cx
       push bx
       pushf
       mov cx,N;נשים את רוחב המטריצה באוגר CX
       .IF(AL==ESC1);האם הכפתור אסקייפ נלחץ?
       MOV TEMPTAV,AX;אם כן,נשים במשתנה זמני
       jmp NEXT0;ונקפוץ לבדיקה
       .ENDIF
 mov TEMPTAV,AX;בכל מקרה נשים כל תו אחר,אבל הפעם גם נמיר למיקומים במטריצה
xor ah,ah;נגזור את ההאוגר הגבוה באוגר הראשי
 sub al,'0';נהפוך למספר פשוט
COR2OFF;נזמן את המקרו שימיר למיקום במטריצה
mov TEMPI2,SI;נשים את מיקום המטריצה במשתנה זמני
  xor si,si;נאתחל את אוגר אינדקס המטריצה הראשית ונצביע לתחילת המטריצה
mov si,offset mat4;
add si,TEMPI2;נוסיף לאוגר האינדקס את מיקום השורה

PRE:;נבדוק האם השורה מלאה,אם לא נצא מהלולאה ונמשיך,אם כן,לא נאפשר קליטה ונבקש קליטת שורה אחרת 
mov bl,[si];
.IF (BL==' ') 
JE NEXT0;יש מיקום פנוי? נצא מהלולאה נמשיך הלאה
.ENDIF;
inc si;אין? נמשיך לחפש
LOOP PRE;
JMP SOF;אם לא מצאנו,נסיים את המקרו ונקלוט מחדש

NEXT0:;השלב הבא
       mov AX,TEMPTAV;נשמור את התו באוגר הראשי
       MOV flagKelet,0;נאפס את דגל הקלט
       xor si,si;
       xor bx,bx
       mov si,offset L_SHURA;מצביע לתחילת מערך השורה
       mov cx,sizeof L_SHURA;נשים באוגר המונה את גודל מערך השורה
       
L1:mov bl,[si];;נשים את התו באוגר המשני הנמוך
   cmp bl,al;האם שווה לקלט?
  JE NEXT1;אם כן נעבור לשלב הבא
inc si;אם לא,נגדיל את האינדקס ונמשיך לחפש
LOOP L1;
JMP SOF;לא נמצא? נסיים את המקרו


NEXT1:
.IF((bl==ESC1)&&(flagEscape==FALSE));פה יש ווידואי שלא ניתן לסיים את התכנית בפעם הראשונה שלוחצים אסקייפ,משום שדגל האסקייפ כבוי כל עוד לא הצלחנו לקלוט בפעם הראשונה
xor bx,bx;נאפס את האוגר שלא יפריע ונסיים את התוכנית
JMP SOF;
.ENDIF;

       .IF(bl==ESC1);במידה וכפתור אסקייפ נלחץ
       mov flagEscape,0;נאפס את דגל אסקפיים
	   ;נשחזר את האוגרים ונקפוץ ללואת המילוי
       xor bx,bx;איפוס האוגר המשני,שלא ייגרום לבעיות
	    popf
        pop  si
        pop  bx
        pop  cx
       JMP STARTING;נקפוץ לתג שיתחיל את המילוי 
       .ENDIF;
;במידה ולא קלטנו אסקפייפ אלא מספר מ 1 עד 4 והוא עבר את הבדיקות נסיים את המקרו,נשחזר את אוגרים ונמשיך לשלב הבא
mov flagKelet,1;  מדליק את דגל הקלט,שנוכל לסיים את תהליך הקליטה
SOF:    popf
        pop  si
        pop  bx
        pop  cx
ENDM


;מקרו לקליטת קלט עמודה
CHK_KELET_AMUDA MACRO
;הגדרת תווים לוקליים
LOCAL PRE, NEXT0,NEXT1 , SOF , L1 ,NEXT2;
;דחיפת האוגרים למחסנית
       push si
       push cx
       push bx
       pushf

  xor ah,ah;נאפס את האוגר הגבוהה באוגר הראשי
mov TEMPJ2,ax;נשמור את התו שקלטנו
sub TEMPJ2,'0';נמיר למספר עשרוני את העמודה שנוכל לבצע בדיקות

;נתחיל בחיפש אם התו בכלל נמצא במערך
       xor si,si;
       xor bx,bx
       mov si,offset L_AMUDA;מצביע למערך העמודה
       mov cx,sizeof L_AMUDA;נשים את גודל העמודה באוגר המונה
mov flagKelet,0;איפוס דגל הקלט
L1:mov bl,[si];נשים את ערך התו באוגר BL
   cmp bl,al;האם שווה לערך העמודה שקלטנו?
  JE NEXT1;אם כן נעבור לשלב הבא
inc si;אם לא נגדיל את האינדקס ונמשיך את הלולאה
LOOP L1;כמובן נפחית ממונה אורך המערך 
JMP SOF;אם לא מצאנו נסיים את המקרו

NEXT1:
  xor si,si;
mov si,offset mat4;מצביע לתחילת המטריצה הראשית
add si,TEMPI2;נוסיף תחילת השורה שבא אנחנו רוצים לבצע בדיקה
ADD SI,TEMPJ2;נוסיף את תחילת העמודה
mov bl,[si];נשים באוגר הנמוך של אוגר BX את התו 
.IF(bl!=' ');האם התא תפוס?
xor bx,bx;אם כן נאפס ונסיים את המקרו
JMP SOF
.ENDIF

;אחרת נמשיך לשלב הבא
 xor bx,bx;איפוס אוגר BX
 xor si,si;
MOV CL,N
XOR CH,CH;
mov si,offset mat4;מצביע למטריצה הראשית
add si,TEMPI2;נשים את מיקום השורה שאותה אנחנו רוצים לבדוק
PRE:;נתחיל את הלולאה
mov bl,[si];נשים באוגר הנמוך של  BX
.IF (BL==' ') ;האם נמצא תא פנוי בשורה?
JE NEXT0;אם כן נקפוץ לשלב הבא
.ENDIF;
inc si;אחרת נמשיך לחפש
LOOP PRE;ונפחית מהמונה
xor bx,bx;אם לא מצאנו נאפס את האוגר שלא יפריע
JMP SOF;נסיים את המקרו

NEXT0:
mov flagKelet,1;נדליק את דגל הקלט
SOF:    popf;שחזור האוגרים וסיום המקרו
        pop  si
        pop  bx
        pop  cx
ENDM;סיום המקרו

;מקרו לבדיקת חוקיות הערך שייקים את חוקי הסודקו
CHK_KELET_VALUE MACRO
LOCAL SOF , L1,NEXT1;הגדרת משתנים לוקאליים
;שמירת האוגרים
       push si
       push cx
       push bx
       pushf
       mov flagKelet,0;איפוס דגל הקלט
;איפוס האוגרים
       xor si,si;
       xor bx,bx
 mov si,offset mat4;מצביע למטריצה הראשית
 add si,TEMPI;נוסיף את הארך האינדקס כדיי להגיע למיקום שממנו נתחיל לבדוק
 mov al,[si];
 .IF(AL!=' ');האם שונה מפנוי?
 MOV AL,' ';אם כן נשים באוגר מיקום פנוי ונשלח להדפסה,ונדפיס רווח
mov temp4,3;
MOV flagKelet,1;נדליק את דלק הקלט
SHOW_MATRIX  al;הדפסת התו
popf;שחזור האוגרים
        pop  si
        pop  bx
        pop  cx
JMP SHURA;קפיצה ללולאת קליטת השורה ויציאה כפוייה מהמקרו
.ENDIF
;אחרת נמשיך הלאה

   xor bx,bx;איפוס האוגר
   xor dx,dx;איפוס האוגר
       xor si,si;
       mov si,offset L_VALUE;מצביע למעך הערך
       mov cx,sizeof L_VALUE;נשים א גודל המערך באוגר המונה
mov flagKelet,0;נאפס את דגל הקלט
L1:mov bl,[si];נשים ערך מהמערך באוגר הנמוך
   cmp bl,TEMPNUM;נשווה לתו
  JE NEXT1;האם שווה? נקפוץ לשלב הבא
inc si;אחרת נמשיך לחפש
LOOP L1;נפחית כל פעם אחד מגודל המערך
JMP SOF;אם נכשלנו בבדיקה נקפוץ לתג סיום המקרו

NEXT1:;שלב הבא,בדיקת חוקיות
      .IF((BL==ESC1)&&(flagEscape==FALSE));האם לחצנו אסקייפ אבל דגל האסקייפ מכובה?
;נחשזר את האוגרים
      popf
        pop  si
        pop  bx
        pop  cx
JMP VALUE;נקפוץ לתחילת לולאת קלט הערך ונצא מהמקרו
       .ENDIF;
        .IF((BL==ESC1)&&(flagEscape==TRUE));האם לחצנו על אסקפיים וגם דגל האסקפיים דלוק?
        mov al,' ';;נשים רווח באוגר הנמוך
        add temp4,1;נעלה ב 1 את משתנה שורת הרווח להדפסה
      SHOW_MATRIX DL;הדפסת הרווח
      mov flagEscape,0;איפוס דגל האסקייפ,שלא יפריע
;שחזור האוגרים
      popf
        pop  si
        pop  bx
        pop  cx
       JMP STARTING;קפיצה לולאה המילוי הסודקו
       .ENDIF;

;אם התו איננו אסקפייפ,נעבור לבדיקת חוקיות הערך
mov flag,0;אתחול משתנה הדגל
CEHCK_LOCATION;קריאה למקרו בדיקת השורה והעמודה
.IF(FLAG==FALSE);אם נכשלנו בבדיקה,נשחזר את האוגרים ונחזור לתחילת קליטת הקלט
;איפוס האוגר הראשי ושחזור האוגרים
xor ax,ax;
JMP SOF;קפיצה לתחילת קליטת הקלט
.ENDIF;

mov dx,TEMPJ2;נשמור את העמודה
AND TEMPJ2,254;נוודא שאנחנו בתחילת ריבוע קסם
Magic_Square_Location;זימון בדיקת מיקום ריבוע הקסם
FILL_MINI_Matrix TEMPI3;מילוי ריבוע הקסם
mov flag,0;איפוס הדגל שנוכל לבצע את הבדיקה
CEHCK_MINI_Matrix ;האם המספר מופיע כבר בריבוע הקסם?
.IF(FLAG==FALSE);אם כן הדגל יישאר אפס
;נשחזר את העמודה והאוגרים
mov TEMPJ2,dx;
;איפוס האוגר הראשי ושחזור האוגרים
JMP SOF;נקפוץ חזרה ללולאת הערך
.ENDIF;


;חלק סיום המקרו
;בפעם הראשונה שהצלחנו לקלוט תו
mov flagEscape,1;נשים בדגל האסייפ 1
mov flagKelet,1;  נשים בדגל הקלט 1
SOF:   ;שחזור האוגרים וסיום המקרו 
        popf
        pop  si
        pop  bx
        pop  cx
ENDM

;ממלא את ריבוע הקסם שנוכל לבדוק
;מקבל את מיקום תחילת הריבוע במשתנה INDEX
FILL_MINI_Matrix   macro INDEX;
local L1
local SOF
;שמירת האוגרים
       push ax
       push bx
       push cx
       push si
       pushf 
;אתחול משתנים ומצביעי המטריצה
       xor cx,cx;
       mov cl,N;נשים את רוחב המטריצה באוגר המונה
       xor ax,ax;איפוס האוגר הראשי
       xor bx,bx;
       mov bl,N;נשים את רוחב המטריצה באוגר המשני
       SHR BX,1;נמיר לשורש המטריצה
       xor si,si;איפוס אינדקס ראשי
       xor di,di;איפוס אינדקס משני
       mov si,offset mat4;מצביע לתחילת המטריצה הראשית
       add si,INDEX;מיקום ריבוע הקסם בסודקו
L1:
mov al,[si];נשים את האיבר באוגר הנמוך של האוגר הראשי
mov MiniMatrix[di],al;נשים במיני מטריצה
;ונקדם את האינדקסים
INC SI;
INC DI;
.IF(Di==BX);אם הגענו לסוף רוחב ריבוע הקסם,נרד שורה
add si,bx;
.ENDIF
DEC CX;נפחית את המונה
CMP CX,0;האם הגענו לסוף ריבוע הקסם?
JNZ L1;אם לא נחזור לתחילת הלולאה,אם כן נסיים את המקרו
SOF:;סיום המקרו ושחזור האוגרים
       popf
       pop  si
       pop  cx
       pop  bx
       pop  ax   

endm;סיום המקרו


;מקרו לבדיקה האם מופיע כבר המספר בריבוע הקסם
CEHCK_MINI_Matrix   macro
local L1
local SOF;;שמירת האוגרים
       push ax
       push bx
       push cx
       push si
       pushf 
       xor cx,cx;
       mov cl,N;נשים באוגר המונה את רוחב המטריצה
       xor ax,ax;
       mov al,TEMPNUM;נשים באוגר הנמוך של האוגר הראשי את התו  שאנחנו רוצים לבדוק
       xor si,si;איפוס האינדקס
       mov si,offset MiniMatrix;מצביע לריבוע הקסם
L1:CMP [si],al;האם מופיע בריבוע?
JE SOF;אם כן נסיים את המקרו
INC SI;אם לא נקדם את האינדקס
LOOP L1;ונמשיך לבדוק
mov flag,1;במידה ולא מצאנו,הבדיקה תקינה ונשים בדגל אחד

SOF:;סיום המקרו ושחזור האוגרים
       popf
       pop  si
       pop  cx
       pop  bx
       pop  ax   

endm

;מקרו לבדיקת שורה ועמודה
CEHCK_LOCATION   macro
;הדרת תגיות לוקאליות
local L1
local L2
local SOF;
local NEXT;
;שמירת האוגרים על ידי דחיפתם למחסנית
       push ax
       push bx
       push cx
       push si
       pushf 
       xor bx,bx;נאפס את האוגר המשני
       mov bl,N;נשים את ערך רוחב המטריצה באוגר
       xor ax,ax;נאפס את האוגר הראשי
       xor si,si;
       mov si,offset mat4;מצביע למטריצה הראשית
       add SI,TEMPI2;מקבל את מיקום השורה כך שנצביע אליה שנוכל להתחיל בבדיקה
       mov  cl , N;נשים באוגר המונה את רוחב המטריצה
       xor  ch , ch ; cx = N
       MOV AL,TEMPNUM;המספר שאנחנו רוצים לבדוק יושם באוגר הראשי בחלקו הנמוך
     
;נעבור על השורה
 L1: 
 CMP AL,[si];
 JE SOF;אם מצאנו מספר כפול נקפוץ לסיום המקרו
  INC SI;נמשיך לבדוק
LOOP L1;נפחית מאוגר המונה עד שנסיים לעבור
;נעבור לבדיקת העמודה
        mov  cl , N;רוחב המטריצה באוגר המונה
        xor si,si;
        mov si,OFFSET MAT4;מצביע למטריצה הראשית
       add SI,TEMPJ2;מיקום העמודה

;נעבור על העמודה
   L2: 
  CMP AL,[si];נשווה אם התו
  JE SOF;אם מצאנו נסיים את המקרו
 add si,bx;נוסיף את ערך האוגר המשני בשביל לעבור לעמודה הבאה
 LOOP L2;נפחית בכל פעם אחד מאוגר המונה עד סיום הלולאה
mov flag,1;נחזיר אחד אם לא קיים,0 אם כן
 SOF:;סיום המקרו ושחזור האוגרים
       popf
       pop  si
       pop  cx
       pop  bx
       pop  ax    

endm


;מקרו להדפת תווים במערכים
SHOW_TAV MACRO STR
MOV AH,2
mov dl,al;נעביר לאוגר DL
INT 21H;נקרא לשירות
ENDM;נסיים את המקרו

SHOW_MATRIX2 MACRO STR
local NEXT;
MOV AH,2
mov dl,[si];
INT 21H
 MOV DL,' ' ;מוסיף רווח
 .IF(TEMP4==N);האם הגענו לסוף שורת המטריצה?
mov DL, 0DH
mov DL, 0AH
int 21H
MOV ah, 02h
MOV TEMP4,0;אם כן,נרד למה ונאפס את המונה
.ENDIF
 INT 21h
ENDM

;מקרו שמראה את קלט המטריצה לפני ההדפסה הסופית
SHOW_MATRIX MACRO STR
MOV AH,2
mov dl,al;
INT 21H
 MOV DL,' ';רווח
 mov bx,3;
 INT 21H
 MOV DL,' ' ;רווח
 INT 21H
 MOV DL,' ' ;רווח
  INT 21H
 MOV DL,' ' ;רווח
  INT 21H
 MOV DL,' ' ;רווח
  INT 21H
 MOV DL,' ' ;רווח
   INT 21H
 MOV DL,' ' ;רווח
    INT 21H
 MOV DL,' ' ;רווח
 .IF(TEMP4==bL);
MOVDOWN
MOV ah, 02h
 INT 21h
MOVDOWN;רווח שורה
MOV TEMP4,0;נאפס את המונה
.ENDIF;סיום התנאי

ENDM;סיום המקרו
DSEG    SEGMENT
  ;
  ;
  L_SHURA       DB      '0123',ESC1; אפשרויות שורה ; escape ;שנוכל לצאת נשים
  L_AMUDA       DB      '0123';אפשרויות העמודה
  L_VALUE       DB      '1234',ESC1;שנוכל לצאת escape אפשרויות ערך,נשים 
 mat4  DB   N*N DUP(' ') ;מטריצה 4 על 4
                       
   HelpMat DB   N*N DUP(' ')  ;מטריצת עזר 4 על 4

MiniMatrix DB N DUP(' ');ריבוע הקסם,מטריצה בגודל 2 על 2
     
  ;מערך המיקומים הפנויים
LocationsArray DW 40 DUP(0); מערך מילים שמכיל את מיקומי המקומות הפנויים בסודקו

;מערך שמדפיס את המיקומים
Locations1 DB   "Shura:  Amuda:  Value:",0;מערך שמדפיס את ערך השורה,העמודה והמספר שאותם אנחנו קולטים

  ERROR DB  "ERROR! ","Sudoku Couldn't be Solved!",0;מערך שמדפיס שגיאה
  
  NAME1 DB  "Done By Ziv Shamir",0;מערך שמדפיס את שם כותב התוכנת

 Original DB  "The Original Sudoku Is:",0;מערך שמדפיס הודעה על זה שזה הסודוקו המקורי לפני הדפסת הסדוקו המקורי


  SOLVEDMATRIX DB  "Sudoku Is Solvable,The Solution Is:",0;
;מערך שמדפיס הדועה שהסודקו ניתן לפתרון
  
  ENTER1 DB  "Enter Sudoku To Solve,To Finish Press Escape:",0;מערך שמבקש לקלוט סודקו

  TEMPDI DW 0;אוגר את מיקום מערך התאים הפנויים
  TEMPFIRST DW 0;מסמן את מיקום התא הריק הראשון
  FLAGFIRST DB 0;מסמן
  TEMPCX DW 16;משתנה,מן CX שני
  TEMPJ DW 0;שומר עמודה
  TEMPI DW 0;אינדקס המטריצה
  TEMPJ2 DW 0; שומר עמודה
  TEMPI2 DW 0;שומר שורה
  TEMPI3 DW 0;מיקום ריבוע הקסם
  ERRORChacker DB 0;מונה שגיאות
  TEMPTAV DW 0;משתמש לאיגור זמני של התו
  TEMPNUM DB '1';משתנה תו שנשים במטריצה
  TEMP4 DB 0;מונה רווחים ,נועד להדפסה
  miniN DB 2;משתנה שמכיל את שורש רוחב המריצה
  flag DB  0;משתנה דגל,משמש לבדיקה האם הבדיקה עברה בהצלחה או לא
  flagKelet DB  0;דגל שמסמן אם קליטה או לא
  flagEscape DB  0;דגל שמסמן אם ניתן ללחוץ על כפתור אסקפיים
DSEG    ENDS

SSEG    SEGMENT STACK
        dw      100h dup(?)
sseg    ends
CSEG    SEGMENT  WORD PUBLIC  'CODE'

ASSUME  CS:CSEG,DS:DSEG,SS:SSEG

START   PROC    FAR
        push    ds
        mov     ax,0
        push    ax
        MOV     AX,DSEG
        MOV     DS,AX
;תחילת התוכנית הראשית
 ;נדפיס את שם הכותב
xor si,si;אתחול אינדקס המטריצה הראשי
xor di,di;אתחול אוגר אינדקס מטריצת העזר
xor ax,ax;איפוס האוגר הראשי
mov di,offset NAME1;מצביע למערך השם
mov al,[DI];נשים באוגר הנמוך
N4:;תחילת לולאת ההדפסה
mov dl,AL;נשים באוגר DL
ADD DL,'0';נוסיף תו אפס,כלומר ממיר לאותיות
SHOW_TAV DL;קורא למקרו הדפסת מילים במערך
inc DI;נגדיל את האינדקס  1
mov al,[DI];נשים את הערך הבא באוגר הנמוך
CMP AL,0;האם הגענו לסוף המערך??
jNE N4;אם לא נחזור לתחילת הלולאה,אם כן נסיים

;נקרא למקרו רווח שורה שלא יהיה צמוד
MOVDOWN
MOVDOWN

;נבקש לקלוט את הסודקו

xor di,di;איפוס אינדקס המצביע של המערך
xor al,al;איפוס האוגר הנמוך
mov di,offset ENTER1;מצביע לתחילת המערך
mov al,[DI];נשים את האיבר הראשון באוגר הנמוך וניכנס ללולאה
E:
mov dl,AL;נשים ב DL
ADD DL,'0';נמיר לקריטורוריה שיופיע במסך
SHOW_TAV DL;נזמן את מקרו ההדפסה
inc DI;;נעבור לאיבר הבא במערך
mov al,[DI];;ונשים באוגר הנמוך
CMP AL,0;האם הגענו לסוף המערך?
jNE E;אם לא נחזור לתחילת הלולאה,אם כן נסיים את הלולאה ונמשיך בתכנית

;רווח שתי שורות על ידי זימון המקרו פעמיים
MOVDOWN
MOVDOWN 

;נדפיס מיקומים וערך
xor di,di;
xor al,al
mov di,offset Locations1;מצביע לתחילת מערך שירשום שורה,עמודה וערך
mov al,[DI];נשים איבר ראשון באוגר הנמוך
LOCATIONS:;תחילת הלולאה
mov dl,AL;נשים באוגר  DL
ADD DL,'0';נמיר לקריטרטוריה
SHOW_TAV DL;זימון מקרו ההדפסה
inc DI;נעבור לאיבר הבא במערך
mov al,[DI];
CMP AL,0;האם הגענו לסוף המערך?
jNE LOCATIONS;אם לא הגענו לסוף המערך נקפוץ לתחילתו
;נשים רווח שורה להדפסה הבאה
MOVDOWN
MOVDOWN

;אתחול המשתנים ומצביעים למטריצות
xor dx,dx;
xor ax,ax
mov al,N;
MUL AL;
mov cx,AX;
xor ax,ax;
xor si,si;
xor di,di;
xor dx,dx;
mov si,offset mat4;
mov di,offset HelpMat;
;ניכנס ללולאה שתקלוט את המיקומים והערכים
L0:
L1:     ;לולאת שורה,נקלוט ערכים ונבצע בדיקות
       SHURA:    
       KELET;זימון מקרו הקלט
      CHK_KELET_SHURA;זימון מקרו בדיקת השורה
         .IF(flagKelet==TRUE);האם עברנו את הבדיקה בהצלחה?
          ADD TEMP4,1;נגדיל את מונה שורת ההדפסה באחד
          mov dl,al;נשים את התו באוגר DL
          xor dh,dh;  נוודה שיש  ערך רק ב DL
           mov  TEMPTAV,DX;נשמור את

      SHOW_MATRIX DL;נזמן מקרו הדפסה  ונפדיס את התו
      JMP AMUDA;נקפות ללואת העמודה
      .ENDIF;
      JMP SHURA;אם לא עמדנו בתנאי,נקפוץ חזרה ללואת השורה ונקלוט מחדש
      add TEMP4,1;נעלה את מונה שורת במטריצה באחד
      AMUDA:mov flagKelet,0;איפוס דגל הקלט
         KELET;זימון מקרו הקליטה
      CHK_KELET_AMUDA;זימון מקרו קליטת העמודה
      .IF(flagKelet==TRUE);האם עברנו את הבדיקה בהצלחה?
        ADD TEMP4,1;אם כן,נוסיף 1 למונה שורת הרווח
        mov dx,TEMPTAV;נשמור את תו העמודה באוגר DX
        mov dh,al;
      mov  TEMPTAV,dx;
        SHOW_MATRIX DH;מדפיס את העמודה
      xchg dh,dl;שם את ערך העמודה באוגר הנמוך
      xor dh,dh;איפוס האוגר הגבוהה
      mov TEMPJ2,dx;נשמור את העמודה במשתנה
      sub TEMPJ2,'0';נמיר למספר עשרוני
     mov ax,TEMPTAV;נשים את התו באוגר הראשי
     xor ah,ah;נאפס את האוגר הגבוהה
     sub al,'0';נמיר למספר עשרוני
     .if(al>FIRSTLOCATION);האם גדול מהמיקום הראשון?
     mov BL,N;אם כן נשים את רוחב המטריצה באוגר המשני הנמוך
     mul BL;ונכפיל את התו העשרוני ברוחב המטריצה
     .endif;
      MOV TEMPI3,AX;נשים באינדקס מיקום ריבוע הקסם
      mov TEMPI2,ax;ובאינדקס השורה
      JMP VALUE;נקפוץ ללואת קליטת הערך
       .ENDIF;
      JMP AMUDA;אם לא עברנו את הבדיקה,נקלוט שוב את העמודה
 VALUE: ;לולאת הערך
        xor ax,ax;נאתח את האוגר הראשי
        mov al,N;נשים את רוחב המטריצה
        MUL miniN;ערך תחילת השורה הבאה
       .IF(TEMPI3<AX);האם אנחנו נמצאים בריבועים העליונים?
       mov TEMPI3,0;אם כן, נשים את אינדקס תחילת ריבוע הקסם בתחילת המטריצה
      .ENDIF
      .IF(TEMPI3>=AX);האם אנחנו נמצאים בריבועי הקסם התחתונים?
       mov TEMPI3,AX;אם כן,נצביע לתחילת ריבוע הקסם הראשון בחלק התחתון של המטריצה
      .ENDIF
  mov DX, TEMPTAV;נשים באוגר DX את התו
     SUB DH,'0';נמיר למספר עשרוני את האוגר הגבוהה
     SUB DL,'0';נמיר למספר עשרוני את האוגר הגבוהה
 mov ax,dx;נשים באוגר AX 
     COR2OFF;נזמן את מקרו ההמרה למיקום המטריצה 
MOV TEMPI,SI;נשים את מיקום המטריצה במשתנה
xor si,si;
mov si,offset mat4;נצביע באינדקס לתחילת המטריצה
add si,TEMPI;נוסיף את מיקום המטריצה
  KELET;קורא למקרו קליטה
  mov TEMPNUM,al;נשמור את הקלט 
CHK_KELET_VALUE;נזמן את מקרו בדיקת הלקט
   .IF(flagKelet==TRUE);האם עברנו את הבדיקה בהצלחה?
   add temp4,1;אם כן,נוסיף 1 למונה הדפסת שורת רווח
   mov al,TEMPNUM;נחזיר לאוגר AL את התו
   SHOW_MATRIX dL;נדפיס את התו
      mov flagKelet,0;נאפס את דגל הקלט
xor si,si;
xor di,di;
mov si,offset mat4;מצביע למטריצה הראשית
mov di,Offset helpmat;מצביע למטריצת עזר
add si,TEMPI;מיקום נוכחי
add di,TEMPI;מיקום נוכחי
mov al,TEMPNUM;שם את התו באוגר AL
mov [si],al;נשים במיקום את הערך במטריצה הראשית
mov [di],al;נשים במיקום את הערך במטריצה העזר
   JMP  NEXTKLITA;מכיוון שעברנו את הבדיקות וההשמה בהצלחה נקפוץ לשלב הבא
          .ENDIF;
        JMP VALUE;אם לא עברנו נקלוט מחדש את הקלט
        NEXTKLITA:
      DEC TEMPCX;נפחית את המונה  ב 1
      CMP TEMPCX,0;סיימנו לקלוט לכל המקומות האפשריים?
       JNZ L0;   אם לא נקפוץ חזרה לתחילת הלולאה,אם כן נסיים את לולאת הקליטה
 ;נרד למטה בהדפסה      
MOVDOWN

;נעבור ללולאה הראשית ונעבור פה בשיטת  Backtracking
STARTING:
mov flagEscape,0;נאפס את דגל אסקייפ שלא יפריע
xor di,di;
xor al,al
mov di,offset Original 
mov al,[DI];
OriginalPrinting:;הדפסת הודעה על כך שמדובר בסודוקו המקורי
mov dl,AL;
ADD DL,'0';המרה לתו קריטרטורי
SHOW_TAV DL;זימון מקרו ההדפסה
inc DI;נעבור לאיבר הבא
mov al,[DI];נשים באוגר הנמוך
CMP AL,0;האם הגענו לסוף המערך?
jNE OriginalPrinting;אם לא נחזור לתחילת הלולאה,אם כן נצא מהלולאה

;נרד שתי שורות למטה בעזר קריאה למקרו
MOVDOWN
MOVDOWN

xor ah,ah;איפוס האוגר הגבוהה
mov al,N;נשים את רוחב המטריצה באוגר הנמוך
MUL AL;נמיר לגודל המטריצה בהכפלה עצמית
mov cx,ax;נשים במונה המטריצה
xor si,si;
mov si,offset mat4;מצביע לתחילת המטריצה הראשית
mov TEMP4,1;נאתחל את מונה הדפסת שורת הרווח באחד
PrintingMatrix:; לולאת הדפסת המטריצה
   SHOW_MATRIX2 DL;זימון מקרו הדפסה למטריצה
        INC SI;נקדם את האינדקס
        add TEMP4,1;נוסיף אחד למונה הדפסת שורת המטריצה
        DEC CX;נפחית אחד ממונה המטריצה
        CMP CX,0;האם הגענו לסוף המטריצה?
    JNZ PrintingMatrix;אם לא נמשיך,אם כן נסיים את הלולאה ונמשיך לשלב הבא

   ;נרד שורה למטה בעזרת מקרו
MOVDOWN
;אתחול האוגרים,המצביעים והאינדקס
xor bx,bx;
mov al,N;
xor ah,ah;
MUL AL;
mov cx,AX;
xor ax,ax;
xor di,di;
xor si,si;
mov TEMPI,0;
mov si,offset mat4;מצביע למטריצה הראשית
;נאתחל את מערך המיקומים
PRE:
mov al,[si];שם איבר באוגר הנמוך
.IF(AL==' ');האם הוא פנוי?

mov ax,TEMPI;נשים אותו באוגר הראשי
mov LocationsArray[bx],ax;ונשים את מיקום האיבר הפנוי במערך המיקומים
ADD bx,2;;ונתקדם בו למיקום הבא
.ENDIF;
inc TEMPI;;נשתמש פה במונה משתנה שלא יפריע עם ערך המיקומים,נקדם אותו בכל מקרה
inc si;;בכל מקרה נתקדם במטריצה
LOOP PRE;האם הגענו לסוף המטריצה? אם לא נמשיך,אם כן נצא מהלולאה

;לולאת אתחול המשתנים,כולל מונה המטריצה,בקרא לה שוב ושוב כדיי לעבור על הסודוקו,בשביל לעבור על ריבועי הקסם העמודה והשורה במקוריים נצטרך לאתחל את המשתנים והמונה
Recall:
xor di,di;
MOV TEMPNUM,'1';
MOV ERRORChacker,0;אתחול מונה השגיאות
mov TEMPI,0;אתחול אינדקס המטריצה
mov TEMPJ,0;אתחול אינדקס העמודה
mov TEMPJ2,0;אתחול אינדקס עמודת עזר ובודק מתיי נעבור לריבוע הקסם הבא
mov TEMPI2,0;אתחול משתנה אינדקס משני משמש לבדיקת שורה  שממנה אנחנו רוצים להתחיל לסרוק
mov TEMPI3,0;משתנה אינדקס עזר,משמש לתחילת שורה בריבוע הקסם
mov flag,0;אתחול משתנה הדגל
mov al,N;
xor ah,ah;
MUL AL;נכפיל בעצמו כדיי לקבל את אורך המטריצה הכולל
mov cx,AX;אתחול מונה המטריצה
mov TEMPCX,AX;
xor ax,ax;
xor di,di;איפוס אינדקס מטריצת העזר
xor si,si;איפוס אינדקס המטריצה הראשי,מכיוון שיש לנו איתו הרבה שימושים,נשתמש במשתנה עזר בנוסף אליו
mov si,offset mat4;מצביע לתחילת המטריצה הראשית
FILL_MINI_Matrix TEMPI3;מילוי ריבוע הקסם,מכיוון שאנחנו מתחילים תמיד מההתחלה,נמלא את ריבוע הקסם הראשון לפי תוכן המטריצה

L2: ;לולאת מילוי,הלולאה תנסה למאלות את הסודקו לפי הכללים בדרך פשוטה יחסית,במידה ונגלה בעיות במילוי נקפוץ ללולאת השגיאות הלולאה תסתיים ברגע שהמונה יגיע ל0
    mov al,[si];
    cmp al,' ';האם הגענו למיקום פנוי?
    JNE NEXT;אם לא,נעבור לבדוק אם המשך הסדוקו תקין,בלי לשים או לשנות שום דבר
CHECKING:
CEHCK_LOCATION;זימון מקרו בדיקת העמודה והשורה
mov DL,TRUE
CMP flag,DL;;האם המיקום תקין?
JNE CONTINUE;;אם לא נקפוץ לתג שיוסיף 1 למונה השגיאות
mov flag,0;;אם כן,נאפס את הדגל ונמשיך לבדיקה הבאה
CEHCK_MINI_Matrix;זימון המקרו שממלא את ריבוע הקסם לפי המיקום שלו במטריצה
MOV DL,TRUE
CMP flag,DL;האם ריבוע הקסם תקין?
JE ADDING;;אם כן בכל מקרה נקפוץ מקרו שבודק אם יש צורך להוסיף כי הוא כולל בדיקה משל עצמו
CONTINUE:
add ERRORChacker,1;מוסיף 1 למונה השגיאות
.IF(ERRORChacker==N);האם מיצינו את כל המספרים האפשריים?
mov BL,FIRSTLOCATION;נשים את המיקום הראשון באוגר
XOR BH,BH
;האם נמצא במיקום הראשון?
CMP TEMPDI,BX;;אם כן,קודם כל נבדוק אם אנחנו במיקום פנוי הראשון
JMP ERRORMASSAGE;אם כן נקפוץ ללואת השגיאות
SUB TEMPDI,2;אחרת נרד למיקום הקודם במערך המיקומים
JMP ERRORMASSAGE;ורק אז נקפוץ למיקום הקודם
.ENDIF

;אם לא עמדנו בכל בתנאים נוסיף למספר שאנחנו רוצים לשים 1
ADDING:
.IF(flag==FALSE);;האם נכשלנו בבדיקות?
add TEMPNUM,1;;נעלה את משתנה ההשמה ב 1
JMP CHECKING;;נקפוץ חזרה ללואת הבדיקות
.ENDIF
;אם לא,נשים אותו במיקום הריק

xor ax,ax;אתחול האוגר הראשי
mov al,TEMPNUM;נשים את המספר התקין באוגר הנמוך
xor si,si;נצביע למיקום שאנחנו רוצים למלאות
mov si,offset mat4;
add si,TEMPI;
mov [si],al;נשים במיקום את המספר שעומד בתנאי הסודוקו


ADD TEMPDI,2;אחרי ששמנו איבר תקין במיקום,נגדיל את אינדקס מערך המיקומים  ב2,משום שמדובר במערך מילים
jmp N0;נקפות לתגית שתכין את המטריצה לקידום,תוך בדיקה אם יש לעבור לתחילת ריבוע הקסם הבא

;במידה והתא כבר מולא במספר נבצע בדיקות האם יש בעיות,כלומר יש בעמודה או בשורה מספר כמוהו
NEXT:
mov AL,[SI];נשמור אל משתנה המיקום
mov dl,-1;נשים מינוס אחד,שלא יפריע לבדיקה
mov [si],dl;נשים במיקום ונמשיך את הבדיקה
MOV TEMPNUM,AL;נשים אותו במשתנה זמני
CEHCK_LOCATION;זימון מקרו בדיקת העמודה והשורה
.IF(FLAG==FALSE);האם נכשלנו בבדיקה?
mov al,TEMPNUM;בכל מקרה נחזיר את המשתנה למיקום
mov [si],al;
JMP ERRORMASSAGE;נקפוץ ללואת השגיאות
.ENDIF;

xor si,si;איפפוס האידקס
mov si,offset mat4;מצביע לתחילת המטריצה הראשית
add si,TEMPI;מקבל את ערך אינדקס המטריצה
MOV AL,TEMPNUM;מקבל את המספר החוקי
mov [SI],al;שם בתא הריק את המספר שעומד בתנאים של הסודוקו
N0:
mov flag,0;נאתחל את משתנה הדגל שנוכל שוב להשתמש בו
add TEMPJ2,1;נגדיל את מונה העמודה ב 1
add TEMPI,1;נגדיל את מונה המטריצה ב 1
MOV ERRORChacker,0;בו את מונה השגיאות שנוכל להשתמש בו

xor ax,ax
mov al,N;
MOV bL,miniN;נשים את שורש המטריצה באוגר הנמוך של BX
div bl;נחלק בשורש הרוחב
;האם הגענו לתחילת ריבוע קסם חדש?
.IF(TEMPJ2==AX)
ADD TEMPI3,AX;אם כן,נעבור אליו
FILL_MINI_Matrix TEMPI3;נזמן את מקרו מילוי המיני מטריצה שנוכל ליצור תמונת ראי של ריבוע הקסם לבדיקות
.ENDIF;

mov AL,N;נשים את רוחב המטריצה באוגר הנמוך
.IF(TEMPJ2==AX);האם הגענו לרוחב המטריצה?
add TEMPI2,AX;נעבור לתחילת השורה הבאה במשתנה שנוכל לבצע בדיקת מיקומים
mov AL,miniN;נשים את שורש רוחב המטריצה באוגר
sub TEMPI3,AX;נחזור לתחילת ריבוע הקסם הקודם
FILL_MINI_Matrix TEMPI3;ניצור תמונת ראי של מיקום ריבוע הקסם הנוכחי במיני מטריצה
MOV TEMPJ2,0;;נאפס את אינדקס העמודה
.ENDIF;

MOV AL,N;נשים את רוחב המטריצה באוגר הנמוך
mul miniN;נכפיל בשורש הרוחב
.IF(TEMPI==AX);האם הגענו לשורת ריבוע קסם חדש?
add TEMPI3,AX;נקפוץ אליה
FILL_MINI_Matrix TEMPI3;נמלא את המיני מטריצה כדיי ליצור תמונת ראי של ריבוע הקסם
xor ax,ax;ונאפס את האוגר הראשי
.ENDIF
xor si,si;
mov si,offset mat4;מצביע למטריצה הראשי
add si,TEMPI;המיקום הנוכחי שבו אנו נמצאים
MOV TEMPNUM,'1';אתחול משתנה ההשמה
     DEC CX;נפחית ממונה המטריצה ונקפוץ לתחילת הלולאה
JNZ L2;
JMP SCUSSES1;עברנו את כל הבדיקות והמילווים וגילנו שהסדוקו תקין,נקפוץ ללולאת ההדפסה של הסודקו הפתור

;לולאת השגיאות,בודקת אם הגענו למיקום הראשון והאם אפשר להמשיך או פשוט מגדילה באחד את המיקום הנוכחי ומזמנת את הלולאה הראשית  תוך כדיי אתחול המשתנים
ERRORMASSAGE:
.IF(TEMPDI==FIRSTLOCATION);האם אנחנו במיקום הראשון במערך המיקומים?
JMP CHANGEFIRST;אם כן,נקפוץ לתו מיוחד שיטפל במיקום הראשון,אם לא,נמשיך
.ENDIF
xor bx,bx;
xor si,si;
mov si,offset mat4;מצביע לתחילת המטריצה הראשית
xor di,di;
mov di,offset Helpmat
add  bx,TEMPDI;
add si,LocationsArray[BX];נוסיף את הערך שבו אינדקס מערך המיקומים נמצא כדיי שנוכל להגיע למיקום הבעייתי
add di,LocationsArray[BX];
mov al,[si]
add AL,1;
.IF(AL==Max);האם עברנו את המספר המקסימלי שאנחנו יכולים לשים?
mov al,' ';אם נשים רווח באוגר הנמוך של AX
sub TEMPDI,2;נחזור אחורה במערך המיקומים
MOV [SI],al; נאפס את המיקום במטריצה הראשית והעזר
MOV [dI],al;
JMP ERRORMASSAGE;נקפוץ חזרה ללולאת השגיאות
.ENDIF
mov [si],al;נשים במטריצה הראשית
mov [di],al;נשים במטריצת העזר

JMP RECALL;נקפוץ חזרה ללואת המילוי ונאתחל את המשתנים,האיברים  במטריצה שלא שינינו לא יושפעו

CHANGEFIRST:;תגית שמשנה את המיקום הראשון הפנוי
xor si,si
mov si,offset mat4;נצביע לראשית המטריצה הראשית
xor di,di
mov di,offset helpmat;
add si,LocationsArray[0];נוסיף למטריצת העזר והראשית את ערך המיקום שבוא התא נמצא
add di,LocationsArray[0];
mov al,[si];נשים את האיבר באוגר AL

add AL,1;נגדיל ב 1
.IF((AL<MAX)&&(AL!=AboveSpace));(האם מיצינו את כל האפשרויות או שהתא נשאר ריק אחרי הפעם הראשונה?(שמתי ! משום שהוא שווה ככה אחרי הגדלה ב 1 במידה והתא נשאר ריק
mov [si],al;;אם לא,נשים במיקום המטריצה הראשית והמשנית
mov [di],al;
mov TEMPDI,2;נגדיל את מונה מערך המיקומים ב 2
JMP ResumeMat;נשחזר נקפוץ ללולאה שתוודא שחזור המטריצה המקורית,המיקום הראשון שנמצא והערכים נקלטו בתחילת התכנית לא יושפעו
.ENDIF
;אם כן,זה אומר שהסודקו אינו ניתן לפיתרון ונדפיס הודעת שגיאה
PRERROR:
xor si,si;
mov si,offset mat4;מצביע לתחילת המטריצה הראשית
mov TEMP4,1;נגדיל את מונה שורת הרווח באחד
xor di,di;איפוס אינדקס משני
xor ax,ax;איפוס האוגר הראשי
mov di,offset ERROR;מצביע לתחילת המערך שמדפיס הודעת שגיאה
mov al,[DI]; שם את התו הראשון באוגר הנמוך של AX
;תחילת ההדפסה
N3:
mov dl,AL;
ADD DL,'0';נמיר לתו קריטורי
SHOW_TAV DL;נזמן מקרו הדספה
inc DI;נגדיל את האינדקס
mov al,[DI];ונעבור לתו הבא 
CMP AL,0;האם הגענו לסוף המערך?
jNE N3;אם לא נחזור לתחילת הלולאה,אם כן נסיים את הלולאה
JMP SOF;סיימנו להדפיס את הודעת השגיאה,נקפוץ לתגית הסוף ונסיים את התכנית

;לולאה שמאתחלת את המטריצה הראשית  בלי לפגוע במיקומים שכבר מולאו ותקינים
ResumeMat:
xor ax,ax;אתחול האוגר הראשי
mov al,[di];נשים את ערך המיקום באוגר הנמוך
.if(al==' ');האם המיקום פנוי?
mov [si],al;אם כן,נשים במריצה הראשית כדיי למנוע מצב שמיקום מולא שהוא לא תקין יפריע לנו בהמשך התוכנית
.ENDIF;
inc si;נקדם את האינדקסים של המטריצה
inc di;
DEC CX;נפחית ממונה המטריצה 
JNZ ResumeMat; האם הגענו לסוף המטריצה?
JMP Recall;נקפוץ חזרה ללולאה הראשית וננסה למלא מחדש את המטריצה לפי המספר הראשון שהיה פנוי החדש

SCUSSES1:;Label ההצלחה,אומר שהסדוקו ניתן לפתרון
xor di,di;אתחול האינדקס
xor ax,ax;אתחול האוגר הראשי
mov di,offset SOLVEDMATRIX;מצביע למערך  מחרוזת שמדפיס שהסודוקו ניתן לפתרון
mov al,[DI];נשים את האיבר הראשון באוגר הנמוך
;לולאת הדפסה
S1:
mov dl,AL;נשים באוגר הנמוך של DX
ADD DL,'0';נוסיף אפס אסקי שיופיע בהקסה בהדפסה
SHOW_TAV DL;נזמן את מקרו ההדפסה עם האיבר ונדפיס
inc DI;נגדיל את האינדקס באחד
mov al,[DI];נשים את האיבר הבא באוגר הנמוך
CMP AL,0;האם הגענו לסוף המערך?
jNE S1;אם לא,נקפוץ חזרה לתחילת הלולאה אחרת,ניים

;נשים שתי שורות רווח בעזר זימון המקרו פעמיים
MOVDOWN
MOVDOWN

;נדפיס את הסודוקו
xor cx,cx;איפוס מונה המטריצה
xor ax,ax;איפוס האוגר הראשי
mov al,N;נשים את רוחב המטריצה באוגר הנמוך
MUL AL;נכפיל בעצמו כדיי לקבל את גודל המטריצה הכולל
mov cx,ax;נשים באוגר מונה המטריצה
xor si,si;נאפס את אוגר אינדקס המטריצה הראשי
mov si,offset mat4;ונצביע לתחילת המטריצה הראשית
mov TEMP4,1;נשים במשתנה 1 כדיי שלא יפריע ברווח האיברים במטריצה
FILL1: ;תג לולאת הדפסת הסודוקו
   SHOW_MATRIX2 DL;מזמן את מקרו ההדפסת המטריצה 
        INC SI;נגדיל את האינדקס ב 1
        add TEMP4,1;וגם את מונה השורות,שנוכל לבדוק מתי לרדת למטה בהדפסה
        DEC CX;;נפחית אחד ממונה המטריצה
        CMP CX,0;האם הגענו לסוף המטריצה?
    JNZ FILL1;אם לא נקפוץ לתחילת הלולאה,אם כן נצא מהלולאה ונסיים את התוכנית
SOF:;תג סיום התוכנית
        RET   ;<end of program>
start   endp  ;<end of assembler procedure>
CSEG    ENDS  ;<end of segment>
END     START ;<end of file>
